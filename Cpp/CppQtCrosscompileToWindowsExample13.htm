<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>Qt Creator FAQ: How to cross-compile a Qt Creator project from Ubuntu to a windows executable: example 5: any application, using Qt Creator -spec approach</title>
  <meta name="description" content="C++ Qt Creator FAQ: How to cross-compile a Qt Creator project from Ubuntu to a windows executable: example 5: any application, using Qt Creator -spec approach"/>
  <meta name="keywords" content="C++ Qt Creator FAQ: How to cross-compile a Qt Creator project from Ubuntu to a windows executable: example 5: any application, using Qt Creator -spec approach"/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppQtCrosscompileToWindowsExample13.htm">How to cross-compile a Qt Creator project from Ubuntu to a windows executable: example 13: any application, Bezemer way</a></h1>
<p>&nbsp;</p>
<p>This is example 10, and perhaps a viable solutions of answering the <a href="CppQtFaq.htm">Qt FAQ</a> <a href="CppQtCrosscompileToWindows.htm">How to cross-compile a Qt Creator project from Ubuntu to a windows executable?</a>,
which follows [1].</p>
<p>&nbsp;</p>
<!--
<p>Note that this example:</p>
<ul>
  <li>is a console application</li>
  <li>does not call any library, except for the <a href="CppStl.htm">STL</a></li>
  <li>is developed under Ubuntu</li>
  <li>uses <a href="CppMinGw.htm">MinGW</a></li>
  <li>is tested to <a href="CppCompile.htm">compile</a> under <a href="CppQtCreator.htm">Qt Creator</a>, but can be developed in any editor</li>
</ul> -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Downloads</h2>
<p>&nbsp;</p>
<ul>
<!--  <li><a href="CppQtCrosscompileToWindowsExample11.zip">Download the Qt Creator project 'CppQtCrosscompileToWindowsExample11' (zip)</a></li> -->
<!--  <li><a href="CppQtCrosscompileToWindowsExample1.exe">Download the resulting Windows executable 'CppQtCrosscompileToWindowsExample1.exe' (exe)</a></li> -->
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Project information</p>
<p>&nbsp;</p>
<p>Operating system: <a href="http://www.ubuntu.com">Ubuntu</a> 10.04 LTS Lucid Lynx</p>
<p><a href="CppIde.htm">IDE</a>: <a href="CppQtCreator.htm">Qt Creator</a> 2.0.0</p>
<p><a href="CppQtProjectType.htm">Project type</a>: <a href="CppGui.htm">GUI</a> application</p>
<p><a href="CppCompiler.htm">Compiler</a>: <a href="CppGpp.htm">G++</a> 4.4.1</p>
<p><a href="CppLibrary.htm">Libraries</a> used:</p>
<ul>
  <li><a href="CppBoost.htm">Boost</a>: version 1.40</li>
<!--  <li><a href="CppQt.htm">Qt</a>: version 4.7.0 (32 bit)</li> -->
  <li><a href="CppStl.htm">STL</a>: from <a href="CppGcc.htm">GCC</a>, shipped with <a href="CppQt.htm">Qt Creator</a> 2.0.0</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a href="CppQtProjectFile.htm">Qt project file</a></h2>
<p>&nbsp;</p>
<!-- start of code -->
<table border = "1"><tr><td><code>
#-------------------------------------------------<br/>
#<br/>
# Project created by QtCreator 2010-09-25T09:43:28<br/>
#<br/>
#-------------------------------------------------<br/>
QT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; += core<br/>
QT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -= gui<br/>
LIBS += -L/usr/local/lib -lboost_filesystem<br/>
TARGET = CppQtCrosscompileToWindowsExample5<br/>
CONFIG&nbsp;&nbsp; += console<br/>
CONFIG&nbsp;&nbsp; -= app_bundle<br/>
TEMPLATE = app<br/>
SOURCES += main.cpp<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>main.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>/CppQtCrosscompilerToWindowsExample3:<br/>
<a href="CppComment.htm">//</a>/cross-compiling a console application with<br/>
<a href="CppComment.htm">//</a>/a library (that is: <a href="CppBoost.htm">boost</a>_filesystem).<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/filesystem.hpp&gt;<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppGetFilesInFolder.htm">GetFilesInFolder</a>.htm<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppGetFilesInFolder.htm">GetFilesInFolder</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; folder)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppFilesystem.htm">boost::filesystem</a>::path my_folder<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppFilesystem.htm">boost::filesystem</a>::system_complete(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFilesystem.htm">boost::filesystem</a>::path(folder));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<a href="CppFilesystem.htm">boost::filesystem</a>::is_directory(my_folder)) <b><a href="CppReturn.htm">return</a></b> v;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppFilesystem.htm">boost::filesystem</a>::directory_iterator j;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> ( <a href="CppFilesystem.htm">boost::filesystem</a>::directory_iterator i(my_folder);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i <a href="CppOperatorNotEqual.htm">!=</a> j;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( <a href="CppFilesystem.htm">boost::filesystem</a>::is_regular_file( i-&gt;status() ) )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> filename <a href="CppOperatorAssign.htm">=</a> i-&gt;path().filename();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> full_filename <a href="CppOperatorAssign.htm">=</a> folder <a href="CppOperatorPlus.htm">+</a> "/" <a href="CppOperatorPlus.htm">+</a> filename;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppGetPath.htm">GetPath</a>.htm<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppGetPath.htm">GetPath</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; filename)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppFilesystem.htm">boost::filesystem</a>::path(filename).parent_path().string();<br/>
}<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppMain.htm">main</a>(<b><a href="CppInt.htm">int</a></b>, <b><a href="CppChar.htm">char</a></b>* <a href="CppArgc.htm">argv</a>[])<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetFilesInFolder.htm">GetFilesInFolder</a>(<a href="CppGetPath.htm">GetPath</a>(<a href="CppArgc.htm">argv</a>[0]));<br/>
&nbsp;&nbsp;<a href="CppCopy.htm">std::copy</a>(v.begin(),v.end(),<a href="CppOstream_iterator.htm">std::ostream_iterator</a>&lt;<a href="CppString.htm">std::string</a>&gt;(<a href="CppCout.htm">std::cout</a>,"\n"));<br/>
&nbsp;&nbsp;<a href="CppCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Number of files: " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> v.size() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
}<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Process</h2>
<p>&nbsp;</p>
<p>For this example, I use a console project that calls the Boost libraries. If you only need the STL, 
<a href="CppQtCrosscompileToWindowsExample1.htm">example 1: console application, no libaries</a> shows
an easy and successfull approach.</p>
<p>&nbsp;</p>
<p>Additional qmake arguments can be supplied in the 
'Projects -> Build Settings -> Build Steps -> qmake -> Additional arguments' edit.
<ul>
  <li><a href="CppQtCrosscompileToWindowsExample5.png">Where to add qmake arguments (png)</a></li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a href="CppReferences.htm">References</a></h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>[1] http://thebeezspeaks.blogspot.com/2007/12/cross-compiler-blues.html</h>
<p>&nbsp;</p>
<!-- start of code -->
<table border = "1"><tr><td><code>
It is the dilemma of every single FOSS developer. Sure, you want as many people as possible to use your software but you also want to acquaint them with the advantages of FOSS as well. Some developers think it is a non-question: they don't give portability a single thought. Others do, but think it is better to force users by not making their program available under other Operating Systems. "If you want to use my program, that's cool, but switch to Linux first". Other developers, like me, think that it is better to let people use FOSS software under their current Operating System because nobody will make the switch for a single program. It is the strategy that projects like Firefox are using too. It is based on the presumption that when the reasons for switching are piling up the transition is less painful because they can continue to use the programs they know and love.<br/>
<br/>
But that puts us developers into an another painful dilemma. In order to provide these packages we have to have access to these platforms. And that is not something we do lightly. First of all, there is the cost. Commercial Operating Systems are expensive - and let's face it - a pain in the neck due to all the copy protection features. Apart from that, why should you burden yourself with a more complex configuration, another development system and a new learning curve?<br/>
<br/>
Well, there is a solution but it has it's drawbacks too: cross compilation. That means you can continue to use your current Operating System and development system but still are able to support other platforms. It seems too good to be true and - frankly - it is. Almost no distribution has cross development packages in its repository and I think that is a shame. Sure, you can try to compile them yourself but - believe me - that ain't that easy. I have been considering cross compilation for a long time because I didn't want to turn to a MS-Windows machine each and every time I wanted to make a new release. It is really a question of dependency because I always have to rely on my employer to provide such a beast. I run Linux at home and nothing else.<br/>
<br/>
The procedure was always the same. Convert the sources to Microsoft text, put them on a memory stick, take the memory stick wherever the MS-Windows machine was located, copy the sources to the system, compile them, test the compilants, make the package, copy the package back on the memory stick, take the stick home, mount the stick, copy the package to the proper location and we're done. It was even worse when I switched employers because I had to rebuild the entire development system. It usually doesn't come on a vanilla MS-Windows machine nowadays, you know. Who's gonna use a C compiler when you're an IT consultant? Don't bug me with comments like doing this stuff during working hours. We got lunchtime and there is also overtime. It doesn't take me hours to make a package of a simple project, it's more like minutes.<br/>
<br/>
But like I said, cross compilation isn't easy as well. A lot of information is outdated and when not it is mindboggingly complicated. I'm not afraid to compile KOffice or other 50 meg source packages - as a matter of fact that is the standard routine here since I'm still using SUSE 9.2. Never change a running system - but that is not important right now. Another consideration is that just because cross compilation is so complicated I'm afraid to break my current development system. Two compilers on the same system: is that gonna work?<br/>
<br/>
I can tell you that it works. It works even very well. But you have to know where to start and how to get started. A good start is a simple script by Volker Grabsch that builds an MS-Windows C cross compiler and comes with a host of libraries. Just download it - I assume you know how to unpack a .tar.gz - and make a few simple preparations. First of all you have to decide where your compiler is going to reside. I chose /opt/mingw but any other location is alright too. Just remember to edit your .bashrc script in order to change $PATH:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;export PATH=/opt/mingw/bin:$PATH<br/>
<br/>
Next, create the directory. If you're afraid that the script might touch your current development environment, be sure you give yourself full access because you can run the entire script under your current user account:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;su<br/>
&nbsp;&nbsp;&nbsp;&nbsp;cd /opt<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mkdir mingw<br/>
&nbsp;&nbsp;&nbsp;&nbsp;chown habe mingw<br/>
&nbsp;&nbsp;&nbsp;&nbsp;chgrp users mingw<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exit<br/>
<br/>
Be sure to use the user account settings appropriate for your system; this is just an example. Next, make a tiny adjustment to the script. Don't take another route, you won't get a proper compilant. Line 96 to be exact:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PREFIX="/opt/mingw"<br/>
<br/>
Now run it. Take a coffee and wait. Make it a big one. If all goes well you'll end up with a cross compiler in /opt/mingw and you're almost ready to run. You probably will have to make a few adjustments to your Makefile:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CC=$(CROSS)gcc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LD=$(CROSS)ld<br/>
&nbsp;&nbsp;&nbsp;&nbsp;AR=$(CROSS)ar<br/>
<br/>
You may have to add a few others, depending on your project. Please refer to this page on cross compilation or the comments on the freshmeat page. All you have to do is type this:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;make CROSS="i386-mingw32msvc-"<br/>
<br/>
Depending on your project this may be a bit more complex, but now you got plenty of links to solve these issues. If you're using configure, all you have to do is:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;./configure --host="i386-mingw32msvc"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;make<br/>
<br/>
or this:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;./configure --target="i386-mingw32msvc"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;make<br/>
<br/>
Whatever works for you. In my case, it worked fine and I was very happy. So I got reckless and thought I could do the same for MS-DOS. I did some research and found the proper packages. Seemed easy enough, so I downloaded the binutils, crx and gcc packages, became root and installed them with:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpm -Uvh package.rpm<br/>
<br/>
Not much happened. I usually don't use source RPMs since I prefer .tar.gz. I faintly remembered that the last time I used them the beast built a binary package that I could install as usual. But that was several years ago. It could be a lapse of memory, I'm getting older too. After some time I found that they had wound up at /usr/src/packages and that was it. Note this location can be different on your system, you will have to find out for yourself. I decided to build them:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpmbuild -bb djcrx.spec<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpmbuild -bb djcross-binutils.spec<br/>
<br/>
It took another coffee, but there was nothing wrong with that. I ended up with two beautiful packages in RPMS:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpm -Uvh djcrx-2.04pre-5.noarch.rpm<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpm -Uvh djcross-binutils-2.17-5.i686.rpm<br/>
<br/>
Okay, next one:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpmbuild -bb djcross-gcc.spec<br/>
<br/>
Several requirements were not met. I had to have GNAT (what the hell is that??) and older versions of autoconf and automake. Now we're getting in dangerous territory. Two different versions of such crucial tools? Are they completely insane?! I found GNAT. That is an Ada compiler. Well, I can always remove them later. I installed those from DVD. Then the next hurdle, autoconf. I got that one from the GNU repository. First, I check where my autoconf was:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;which autoconf<br/>
<br/>
Then I built the old autoconf as a regular user:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;./configure<br/>
&nbsp;&nbsp;&nbsp;&nbsp;make<br/>
<br/>
Finally I figured out where the beast would install itself:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;make -n install<br/>
<br/>
That proved to be /usr/local/bin. Fair enough. So I ran make install as superuser and renamed all executables, e.g.:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;cd /usr/local/bin<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mv autoconf autoconf-2.13<br/>
<br/>
So, I had managed to resolve most - if not all - dependencies. I just had to edit the specfile (the horror):<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sed -e 's:^\(AUTOCONF_OLD=\).*$:\1/usr/local/bin/autoconf-2.13:' \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-e 's:^\(AUTOHEADER_OLD=\).*$:\1/usr/local/bin/autoheader-2.13:' \<br/>
<br/>
Now try again:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpmbuild -bb --nodeps djcross-gcc.spec<br/>
<br/>
And yes, it ran, it ran!! I took a coffee. I took another one. My girlfiend was sleeping on the bench by now. I made another pot of coffee. Hours were ticking by. It seemed as if the beast was building and rebuilding itself over and over again. The city was completely silent by now. And then the ultimate disaster: the Ada compiler build broke off with an error. Obviously, the build tried to create a whole bunch of compilers, not only C. For my own projects, I only use C. I do not create much F77, Ada or C++ packages for myself or others - zero to be exact - nor do I have any intention to do so. I went to study the spec file again. It seemed you could switch off several compiler builds, which is alright with me. I only want C. So I changed these lines:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--enable-languages=c,ada \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--enable-languages=c,c++,f95,objc,obj-c++,ada || exit 1<br/>
<br/>
to this:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--enable-languages=c \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--enable-languages=c || exit 1<br/>
<br/>
No mercy! Then I prepared another pot of coffee, sighed and tried again. Several hours later, the beast was done. Victory! I've done it, I've done it! It may or may not run, but I have completed the build! Out came a tiny 7 meg RPM.. Now install:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rpm -Uvh djcross-gcc-4.2.2-12ap.i686.rpm<br/>
<br/>
I tested it and it worked fine:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;make CROSS="i586-pc-msdosdjgpp-"<br/>
<br/>
It installs itself into /usr/bin, but now I know that is not a problem. I was appalled by the way I had to make this work. It is these kind of builds that gives Linux a bad rap. And why? It is possible to change an old autoconf to new ones. It is easy to add a simple README or make a simple webpage concerning cross compilation that is not outdated. There is a lesson to be learned here, especially for those who maintain these cross compilation packages. Don't take the easy way, make a little effort. It does not only help FOSS, but also benefits your prospect users. If you don't take their way, they take the highway.<br/>
<br/>
At least, for me the work is done. I'm very happy with my uptodate cross compilers since I can do all my compilation and packaging in the comfort of my Linux box. That's worth a night of hacking and a annoyed girlfriend, isn't it. Well, where the girlfriend is concerned, I'm not too sure.. ;-) <br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>[2] http://freshmeat.net/projects/mingw_cross_env/?branch_id=70526&release_id=268378</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
</body>
</html>
